import{Data as s}from"./index-bd9e6e1e.js";import"./index-2ffb232e.js";function y(t,e,r){let n=0;do{const o=I(t,n,e,r);if(o!==null)n=o;else return!1}while(n<t.length);return!0}function I(t,e,r,n){for(const o of r){o.regex.lastIndex=e;const i=o.regex.exec(t);if(i&&i.index===e)return o.processor(i,n)?o.regex.lastIndex:null}return null}const v={kill:E,arena:S,area:R,enter:W,logout:$,waypoint:b,waypoint_get:T,portal:N,quest:D,quest_text:M,generic:k,reward_quest:P,reward_vendor:q,trial:j,ascend:C,crafting:O,dir:L},x=[{regex:/( *#.*)/g,processor:()=>!0},{regex:/[^{#]+/g,processor:(t,{step:e})=>(e.parts.push(t[0]),!0)},{regex:/\{(.+?)\}/g,processor:(t,e)=>{const r=t[1].split("|"),n=v[r[0]],o=n(r,e);return typeof o=="string"?e.logger.error(o):e.step.parts.push(o.fragment),!0}}];function m(t,e,r){const o={state:e,step:{type:"fragment_step",parts:[]},logger:r};return y(t,x,o)||r.error("invalid syntax"),o.step}function f(t,e){e.is_town_area&&(t.lastTownAreaId=e.id,e.has_waypoint&&t.implicitWaypoints.add(e.id)),t.currentAreaId=e.id}const a="invalid format",d="area does not exist",_="area does not have a waypoint";function E(t,{state:e,logger:r}){if(t.length!=2)return a;const n=t[1],o=s.KillWaypoints[n];if(o)for(const i of o)e.implicitWaypoints.add(i);return{fragment:{type:"kill",value:n}}}function S(t,{state:e,logger:r}){return t.length!=2?a:{fragment:{type:"arena",value:t[1]}}}function R(t,{state:e,logger:r}){if(t.length!=2)return a;const n=s.Areas[t[1]];return n?{fragment:{type:"area",areaId:n.id}}:d}function W(t,{state:e,logger:r}){if(t.length!=2)return a;const n=s.Areas[t[1]];return n?(n.connection_ids.some(o=>o==e.currentAreaId)||r.warn("not connected to current area"),f(e,n),{fragment:{type:"enter",areaId:n.id}}):d}function $(t,{state:e,logger:r}){if(t.length!=1)return a;const n=s.Areas[e.lastTownAreaId];return f(e,n),e.portalAreaId=null,{fragment:{type:"logout",areaId:n.id}}}function b(t,{state:e,logger:r}){{if(t.length!=1&&t.length!=2)return a;if(t.length==2){const n=s.Areas[t[1]];if(!n)return d;!e.implicitWaypoints.has(n.id)&&!e.explicitWaypoints.has(n.id)&&r.warn("missing waypoint");const o=s.Areas[e.currentAreaId];return o.has_waypoint||r.warn(_),e.implicitWaypoints.add(o.id),e.usedWaypoints.add(n.id),f(e,n),{fragment:{type:"waypoint_use",dstAreaId:n.id,srcAreaId:o.id}}}return{fragment:{type:"waypoint"}}}}function T(t,{state:e,logger:r}){if(t.length!=1)return a;const n=s.Areas[e.currentAreaId];return n?(n.has_waypoint||r.warn(_),e.implicitWaypoints.has(n.id)&&r.warn("waypoint already acquired"),e.explicitWaypoints.add(n.id),{fragment:{type:"waypoint_get"}}):d}function N(t,{state:e,logger:r}){if(t.length!=2)return a;const n=s.Areas[e.currentAreaId];switch(t[1]){case"set":return n.is_town_area?"portal cannot be set":(e.portalAreaId=e.currentAreaId,{fragment:{type:"portal_set"}});case"use":{if(e.portalAreaId!=n.id&&!n.is_town_area&&(e.portalAreaId=n.id),!e.portalAreaId)return"portal not set";const o=s.Areas[e.portalAreaId];if(n.id==o.id){if(!n.parent_town_area_id)return"cannot use portal in this area";const i=s.Areas[n.parent_town_area_id];f(e,i),e.portalAreaId=e.currentAreaId}else if(n.id==o.parent_town_area_id)f(e,o),e.portalAreaId=null;else return"can only use portal from town or portal area";return{fragment:{type:"portal_use",dstAreaId:e.currentAreaId}}}}return a}function P(t,{state:e,logger:r}){return t.length!=2?a:(s.Areas[e.currentAreaId].is_town_area||r.warn("quest_reward used outside of town"),{fragment:{type:"reward_quest",item:t[1]}})}function q(t,{state:e,logger:r}){return t.length!=2&&t.length!=3?a:(s.Areas[e.currentAreaId].is_town_area||r.warn("reward_vendor used outside of town"),{fragment:{type:"reward_vendor",item:t[1],cost:t.length==3?t[2]:void 0}})}function k(t,{state:e,logger:r}){return t.length!=2?a:{fragment:{type:"generic",value:t[1]}}}function O(t,{state:e,logger:r}){if(t.length>2)return a;let n;if(t.length==1)n=s.Areas[e.currentAreaId];else if(n=s.Areas[t[1]],!n)return d;return e.craftingAreas.add(n.id),{fragment:{type:"crafting",crafting_recipes:n.crafting_recipes}}}function L(t,{state:e,logger:r}){if(t.length!=2)return a;const n=Number.parseFloat(t[1]);if(Number.isNaN(n))return"dir value is not a number";let o=n%360;return o<0&&(o+=360),o%45!=0?"dir value must be in intervals of 45":{fragment:{type:"dir",dirIndex:Math.floor(o/45)}}}function D(t,{state:e,logger:r}){{if(t.length<2)return a;const n=t[1],o=s.Quests[n];if(!o)return"invalid quest id";let i;if(t.length==2)i=Object.keys(o.reward_offers);else{i=[];for(let c=2;c<t.length;c++)i.push(t[c])}return{fragment:{type:"quest",questId:t[1],rewardOffers:i}}}}function M(t,{state:e,logger:r}){return t.length!=2?a:{fragment:{type:"quest_text",value:t[1]}}}function j(t,{state:e,logger:r}){return t.length!=1?a:{fragment:{type:"trial"}}}function C(t,{state:e,logger:r}){if(t.length!=2)return a;const n="Labyrinth_Airlock";if(s.Areas[e.currentAreaId].id!=n){const c=s.Areas[n];r.warn(`must be in "${c.name}"`)}const i=s.Areas[e.lastTownAreaId];return f(e,i),{fragment:{type:"ascend",version:t[1]}}}class G{constructor(){this.scopes=[],this.logs=[]}pushScope(e){this.scopes.push(e)}popScope(){this.scopes.pop()}withScope(e,r){this.pushScope(e),r(),this.popScope()}buildPrefix(){return this.scopes.length>0?`${this.scopes.join(", ")}: `:""}warn(e){this.logs.push({type:"warning",msg:`${this.buildPrefix()}${e}`})}error(e){this.logs.push({type:"error",msg:`${this.buildPrefix()}${e}`})}drain(e){for(const r of this.logs)switch(r.type){case"warning":e.warn(r.msg);break;case"error":e.error(r.msg);break;default:e.log(r.msg);break}this.logs.length=0,this.scopes.length!==0&&e.warn(`expected 0 scopes got ${this.scopes.length}, ${this.scopes.join(", ")}`)}}const g="Default";function z(t){const e=[];for(const r of t){const n=r.split(/\r\n|\r|\n/g);for(let o=0;o<n.length;o++){const i=n[o],u=/^ *#section *(.*)/g.exec(i);if(u){const p=u[1]||g;e.push({name:p,contents:`#section ${p}`});continue}e.length==0&&e.push({name:g,contents:`#section ${g}`});const l=e[e.length-1];l.contents+=`
${i}`}}return e}function B(t){return t.map(e=>e.contents).join(`
`)}const Q=[{regex:/#endif/g,processor:(t,{state:e,conditionalStack:r,logger:n})=>(r.pop()===void 0&&n.warn("unexpected #endif"),!1)},{regex:/#ifdef *(.*)/g,processor:(t,{state:e,conditionalStack:r})=>{const n=t[1];return n&&r.push(e.preprocessorDefinitions.has(n)),!1}},{regex:/#ifndef *(.*)/g,processor:(t,{state:e,conditionalStack:r})=>{const n=t[1];return n&&r.push(!e.preprocessorDefinitions.has(n)),!1}},{regex:/.*/g,processor:(t,{state:e,section:r,conditionalStack:n,logger:o})=>{if(n.length==0||n[n.length-1]){const c=m(t[0],e,o);c.parts.length>0&&r.steps.push(c)}return!1}}];function U(t,e,r){const n=e*4;let o=0;const i=/^( *)/g.exec(t);i&&(o=i[1].length),o!==n&&r.warn(`expected ${n} whitespace, found ${o}`)}function Y(t,e){const r=new G,n=[];for(const o of t){const i=o.contents.split(/\r\n|\r|\n/g),c={name:o.name,steps:[]};n.push(c),r.pushScope(c.name);const u={state:e,section:c,conditionalStack:[],logger:r};for(let l=0;l<i.length;l++){const p=i[l];if(!p)continue;r.pushScope(`line ${l+1}`);const h=u.conditionalStack.length;y(p.trim(),Q,u);const A=u.conditionalStack.length,w=h>=A?A:h;U(p,w,r),r.popScope()}u.conditionalStack.length!=0&&r.warn("expected #endif"),r.popScope()}for(const o of e.explicitWaypoints)e.usedWaypoints.has(o)||r.warn(`unused waypoint ${o}`);for(const o in s.Areas){const i=s.Areas[o];i.crafting_recipes.length>0&&!e.craftingAreas.has(i.id)&&r.warn(`missing crafting area ${i.id}, ${i.crafting_recipes.join(", ")}`)}return r.drain(console),n}function H(){return{implicitWaypoints:new Set,explicitWaypoints:new Set,usedWaypoints:new Set,craftingAreas:new Set,currentAreaId:"1_1_1",lastTownAreaId:"1_1_town",portalAreaId:null,preprocessorDefinitions:new Set}}export{B as buildRouteSource,z as getRouteFiles,H as initializeRouteState,Y as parseRoute};
